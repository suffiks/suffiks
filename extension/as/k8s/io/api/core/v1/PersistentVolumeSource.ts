// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v1.3.0
//   protoc        v3.20.1

import { Writer, Reader } from "as-proto/assembly";
import { GCEPersistentDiskVolumeSource } from "./GCEPersistentDiskVolumeSource";
import { AWSElasticBlockStoreVolumeSource } from "./AWSElasticBlockStoreVolumeSource";
import { HostPathVolumeSource } from "./HostPathVolumeSource";
import { GlusterfsPersistentVolumeSource } from "./GlusterfsPersistentVolumeSource";
import { NFSVolumeSource } from "./NFSVolumeSource";
import { RBDPersistentVolumeSource } from "./RBDPersistentVolumeSource";
import { ISCSIPersistentVolumeSource } from "./ISCSIPersistentVolumeSource";
import { CinderPersistentVolumeSource } from "./CinderPersistentVolumeSource";
import { CephFSPersistentVolumeSource } from "./CephFSPersistentVolumeSource";
import { FCVolumeSource } from "./FCVolumeSource";
import { FlockerVolumeSource } from "./FlockerVolumeSource";
import { FlexPersistentVolumeSource } from "./FlexPersistentVolumeSource";
import { AzureFilePersistentVolumeSource } from "./AzureFilePersistentVolumeSource";
import { VsphereVirtualDiskVolumeSource } from "./VsphereVirtualDiskVolumeSource";
import { QuobyteVolumeSource } from "./QuobyteVolumeSource";
import { AzureDiskVolumeSource } from "./AzureDiskVolumeSource";
import { PhotonPersistentDiskVolumeSource } from "./PhotonPersistentDiskVolumeSource";
import { PortworxVolumeSource } from "./PortworxVolumeSource";
import { ScaleIOPersistentVolumeSource } from "./ScaleIOPersistentVolumeSource";
import { LocalVolumeSource } from "./LocalVolumeSource";
import { StorageOSPersistentVolumeSource } from "./StorageOSPersistentVolumeSource";
import { CSIPersistentVolumeSource } from "./CSIPersistentVolumeSource";

export class PersistentVolumeSource {
  static encode(message: PersistentVolumeSource, writer: Writer): void {
    const gcePersistentDisk = message.gcePersistentDisk;
    if (gcePersistentDisk !== null) {
      writer.uint32(10);
      writer.fork();
      GCEPersistentDiskVolumeSource.encode(gcePersistentDisk, writer);
      writer.ldelim();
    }

    const awsElasticBlockStore = message.awsElasticBlockStore;
    if (awsElasticBlockStore !== null) {
      writer.uint32(18);
      writer.fork();
      AWSElasticBlockStoreVolumeSource.encode(awsElasticBlockStore, writer);
      writer.ldelim();
    }

    const hostPath = message.hostPath;
    if (hostPath !== null) {
      writer.uint32(26);
      writer.fork();
      HostPathVolumeSource.encode(hostPath, writer);
      writer.ldelim();
    }

    const glusterfs = message.glusterfs;
    if (glusterfs !== null) {
      writer.uint32(34);
      writer.fork();
      GlusterfsPersistentVolumeSource.encode(glusterfs, writer);
      writer.ldelim();
    }

    const nfs = message.nfs;
    if (nfs !== null) {
      writer.uint32(42);
      writer.fork();
      NFSVolumeSource.encode(nfs, writer);
      writer.ldelim();
    }

    const rbd = message.rbd;
    if (rbd !== null) {
      writer.uint32(50);
      writer.fork();
      RBDPersistentVolumeSource.encode(rbd, writer);
      writer.ldelim();
    }

    const iscsi = message.iscsi;
    if (iscsi !== null) {
      writer.uint32(58);
      writer.fork();
      ISCSIPersistentVolumeSource.encode(iscsi, writer);
      writer.ldelim();
    }

    const cinder = message.cinder;
    if (cinder !== null) {
      writer.uint32(66);
      writer.fork();
      CinderPersistentVolumeSource.encode(cinder, writer);
      writer.ldelim();
    }

    const cephfs = message.cephfs;
    if (cephfs !== null) {
      writer.uint32(74);
      writer.fork();
      CephFSPersistentVolumeSource.encode(cephfs, writer);
      writer.ldelim();
    }

    const fc = message.fc;
    if (fc !== null) {
      writer.uint32(82);
      writer.fork();
      FCVolumeSource.encode(fc, writer);
      writer.ldelim();
    }

    const flocker = message.flocker;
    if (flocker !== null) {
      writer.uint32(90);
      writer.fork();
      FlockerVolumeSource.encode(flocker, writer);
      writer.ldelim();
    }

    const flexVolume = message.flexVolume;
    if (flexVolume !== null) {
      writer.uint32(98);
      writer.fork();
      FlexPersistentVolumeSource.encode(flexVolume, writer);
      writer.ldelim();
    }

    const azureFile = message.azureFile;
    if (azureFile !== null) {
      writer.uint32(106);
      writer.fork();
      AzureFilePersistentVolumeSource.encode(azureFile, writer);
      writer.ldelim();
    }

    const vsphereVolume = message.vsphereVolume;
    if (vsphereVolume !== null) {
      writer.uint32(114);
      writer.fork();
      VsphereVirtualDiskVolumeSource.encode(vsphereVolume, writer);
      writer.ldelim();
    }

    const quobyte = message.quobyte;
    if (quobyte !== null) {
      writer.uint32(122);
      writer.fork();
      QuobyteVolumeSource.encode(quobyte, writer);
      writer.ldelim();
    }

    const azureDisk = message.azureDisk;
    if (azureDisk !== null) {
      writer.uint32(130);
      writer.fork();
      AzureDiskVolumeSource.encode(azureDisk, writer);
      writer.ldelim();
    }

    const photonPersistentDisk = message.photonPersistentDisk;
    if (photonPersistentDisk !== null) {
      writer.uint32(138);
      writer.fork();
      PhotonPersistentDiskVolumeSource.encode(photonPersistentDisk, writer);
      writer.ldelim();
    }

    const portworxVolume = message.portworxVolume;
    if (portworxVolume !== null) {
      writer.uint32(146);
      writer.fork();
      PortworxVolumeSource.encode(portworxVolume, writer);
      writer.ldelim();
    }

    const scaleIO = message.scaleIO;
    if (scaleIO !== null) {
      writer.uint32(154);
      writer.fork();
      ScaleIOPersistentVolumeSource.encode(scaleIO, writer);
      writer.ldelim();
    }

    const local = message.local;
    if (local !== null) {
      writer.uint32(162);
      writer.fork();
      LocalVolumeSource.encode(local, writer);
      writer.ldelim();
    }

    const storageos = message.storageos;
    if (storageos !== null) {
      writer.uint32(170);
      writer.fork();
      StorageOSPersistentVolumeSource.encode(storageos, writer);
      writer.ldelim();
    }

    const csi = message.csi;
    if (csi !== null) {
      writer.uint32(178);
      writer.fork();
      CSIPersistentVolumeSource.encode(csi, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): PersistentVolumeSource {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new PersistentVolumeSource();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.gcePersistentDisk = GCEPersistentDiskVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 2:
          message.awsElasticBlockStore =
            AWSElasticBlockStoreVolumeSource.decode(reader, reader.uint32());
          break;

        case 3:
          message.hostPath = HostPathVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 4:
          message.glusterfs = GlusterfsPersistentVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 5:
          message.nfs = NFSVolumeSource.decode(reader, reader.uint32());
          break;

        case 6:
          message.rbd = RBDPersistentVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 7:
          message.iscsi = ISCSIPersistentVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 8:
          message.cinder = CinderPersistentVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 9:
          message.cephfs = CephFSPersistentVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 10:
          message.fc = FCVolumeSource.decode(reader, reader.uint32());
          break;

        case 11:
          message.flocker = FlockerVolumeSource.decode(reader, reader.uint32());
          break;

        case 12:
          message.flexVolume = FlexPersistentVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 13:
          message.azureFile = AzureFilePersistentVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 14:
          message.vsphereVolume = VsphereVirtualDiskVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 15:
          message.quobyte = QuobyteVolumeSource.decode(reader, reader.uint32());
          break;

        case 16:
          message.azureDisk = AzureDiskVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 17:
          message.photonPersistentDisk =
            PhotonPersistentDiskVolumeSource.decode(reader, reader.uint32());
          break;

        case 18:
          message.portworxVolume = PortworxVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 19:
          message.scaleIO = ScaleIOPersistentVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 20:
          message.local = LocalVolumeSource.decode(reader, reader.uint32());
          break;

        case 21:
          message.storageos = StorageOSPersistentVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 22:
          message.csi = CSIPersistentVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  gcePersistentDisk: GCEPersistentDiskVolumeSource | null;
  awsElasticBlockStore: AWSElasticBlockStoreVolumeSource | null;
  hostPath: HostPathVolumeSource | null;
  glusterfs: GlusterfsPersistentVolumeSource | null;
  nfs: NFSVolumeSource | null;
  rbd: RBDPersistentVolumeSource | null;
  iscsi: ISCSIPersistentVolumeSource | null;
  cinder: CinderPersistentVolumeSource | null;
  cephfs: CephFSPersistentVolumeSource | null;
  fc: FCVolumeSource | null;
  flocker: FlockerVolumeSource | null;
  flexVolume: FlexPersistentVolumeSource | null;
  azureFile: AzureFilePersistentVolumeSource | null;
  vsphereVolume: VsphereVirtualDiskVolumeSource | null;
  quobyte: QuobyteVolumeSource | null;
  azureDisk: AzureDiskVolumeSource | null;
  photonPersistentDisk: PhotonPersistentDiskVolumeSource | null;
  portworxVolume: PortworxVolumeSource | null;
  scaleIO: ScaleIOPersistentVolumeSource | null;
  local: LocalVolumeSource | null;
  storageos: StorageOSPersistentVolumeSource | null;
  csi: CSIPersistentVolumeSource | null;

  constructor(
    gcePersistentDisk: GCEPersistentDiskVolumeSource | null = null,
    awsElasticBlockStore: AWSElasticBlockStoreVolumeSource | null = null,
    hostPath: HostPathVolumeSource | null = null,
    glusterfs: GlusterfsPersistentVolumeSource | null = null,
    nfs: NFSVolumeSource | null = null,
    rbd: RBDPersistentVolumeSource | null = null,
    iscsi: ISCSIPersistentVolumeSource | null = null,
    cinder: CinderPersistentVolumeSource | null = null,
    cephfs: CephFSPersistentVolumeSource | null = null,
    fc: FCVolumeSource | null = null,
    flocker: FlockerVolumeSource | null = null,
    flexVolume: FlexPersistentVolumeSource | null = null,
    azureFile: AzureFilePersistentVolumeSource | null = null,
    vsphereVolume: VsphereVirtualDiskVolumeSource | null = null,
    quobyte: QuobyteVolumeSource | null = null,
    azureDisk: AzureDiskVolumeSource | null = null,
    photonPersistentDisk: PhotonPersistentDiskVolumeSource | null = null,
    portworxVolume: PortworxVolumeSource | null = null,
    scaleIO: ScaleIOPersistentVolumeSource | null = null,
    local: LocalVolumeSource | null = null,
    storageos: StorageOSPersistentVolumeSource | null = null,
    csi: CSIPersistentVolumeSource | null = null
  ) {
    this.gcePersistentDisk = gcePersistentDisk;
    this.awsElasticBlockStore = awsElasticBlockStore;
    this.hostPath = hostPath;
    this.glusterfs = glusterfs;
    this.nfs = nfs;
    this.rbd = rbd;
    this.iscsi = iscsi;
    this.cinder = cinder;
    this.cephfs = cephfs;
    this.fc = fc;
    this.flocker = flocker;
    this.flexVolume = flexVolume;
    this.azureFile = azureFile;
    this.vsphereVolume = vsphereVolume;
    this.quobyte = quobyte;
    this.azureDisk = azureDisk;
    this.photonPersistentDisk = photonPersistentDisk;
    this.portworxVolume = portworxVolume;
    this.scaleIO = scaleIO;
    this.local = local;
    this.storageos = storageos;
    this.csi = csi;
  }
}
