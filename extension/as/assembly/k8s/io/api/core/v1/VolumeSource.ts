// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v1.3.0
//   protoc        v3.20.1

import { Writer, Reader } from "as-proto/assembly";
import { HostPathVolumeSource } from "./HostPathVolumeSource";
import { EmptyDirVolumeSource } from "./EmptyDirVolumeSource";
import { GCEPersistentDiskVolumeSource } from "./GCEPersistentDiskVolumeSource";
import { AWSElasticBlockStoreVolumeSource } from "./AWSElasticBlockStoreVolumeSource";
import { GitRepoVolumeSource } from "./GitRepoVolumeSource";
import { SecretVolumeSource } from "./SecretVolumeSource";
import { NFSVolumeSource } from "./NFSVolumeSource";
import { ISCSIVolumeSource } from "./ISCSIVolumeSource";
import { GlusterfsVolumeSource } from "./GlusterfsVolumeSource";
import { PersistentVolumeClaimVolumeSource } from "./PersistentVolumeClaimVolumeSource";
import { RBDVolumeSource } from "./RBDVolumeSource";
import { FlexVolumeSource } from "./FlexVolumeSource";
import { CinderVolumeSource } from "./CinderVolumeSource";
import { CephFSVolumeSource } from "./CephFSVolumeSource";
import { FlockerVolumeSource } from "./FlockerVolumeSource";
import { DownwardAPIVolumeSource } from "./DownwardAPIVolumeSource";
import { FCVolumeSource } from "./FCVolumeSource";
import { AzureFileVolumeSource } from "./AzureFileVolumeSource";
import { ConfigMapVolumeSource } from "./ConfigMapVolumeSource";
import { VsphereVirtualDiskVolumeSource } from "./VsphereVirtualDiskVolumeSource";
import { QuobyteVolumeSource } from "./QuobyteVolumeSource";
import { AzureDiskVolumeSource } from "./AzureDiskVolumeSource";
import { PhotonPersistentDiskVolumeSource } from "./PhotonPersistentDiskVolumeSource";
import { ProjectedVolumeSource } from "./ProjectedVolumeSource";
import { PortworxVolumeSource } from "./PortworxVolumeSource";
import { ScaleIOVolumeSource } from "./ScaleIOVolumeSource";
import { StorageOSVolumeSource } from "./StorageOSVolumeSource";
import { CSIVolumeSource } from "./CSIVolumeSource";
import { EphemeralVolumeSource } from "./EphemeralVolumeSource";

export class VolumeSource {
  static encode(message: VolumeSource, writer: Writer): void {
    const hostPath = message.hostPath;
    if (hostPath !== null) {
      writer.uint32(10);
      writer.fork();
      HostPathVolumeSource.encode(hostPath, writer);
      writer.ldelim();
    }

    const emptyDir = message.emptyDir;
    if (emptyDir !== null) {
      writer.uint32(18);
      writer.fork();
      EmptyDirVolumeSource.encode(emptyDir, writer);
      writer.ldelim();
    }

    const gcePersistentDisk = message.gcePersistentDisk;
    if (gcePersistentDisk !== null) {
      writer.uint32(26);
      writer.fork();
      GCEPersistentDiskVolumeSource.encode(gcePersistentDisk, writer);
      writer.ldelim();
    }

    const awsElasticBlockStore = message.awsElasticBlockStore;
    if (awsElasticBlockStore !== null) {
      writer.uint32(34);
      writer.fork();
      AWSElasticBlockStoreVolumeSource.encode(awsElasticBlockStore, writer);
      writer.ldelim();
    }

    const gitRepo = message.gitRepo;
    if (gitRepo !== null) {
      writer.uint32(42);
      writer.fork();
      GitRepoVolumeSource.encode(gitRepo, writer);
      writer.ldelim();
    }

    const secret = message.secret;
    if (secret !== null) {
      writer.uint32(50);
      writer.fork();
      SecretVolumeSource.encode(secret, writer);
      writer.ldelim();
    }

    const nfs = message.nfs;
    if (nfs !== null) {
      writer.uint32(58);
      writer.fork();
      NFSVolumeSource.encode(nfs, writer);
      writer.ldelim();
    }

    const iscsi = message.iscsi;
    if (iscsi !== null) {
      writer.uint32(66);
      writer.fork();
      ISCSIVolumeSource.encode(iscsi, writer);
      writer.ldelim();
    }

    const glusterfs = message.glusterfs;
    if (glusterfs !== null) {
      writer.uint32(74);
      writer.fork();
      GlusterfsVolumeSource.encode(glusterfs, writer);
      writer.ldelim();
    }

    const persistentVolumeClaim = message.persistentVolumeClaim;
    if (persistentVolumeClaim !== null) {
      writer.uint32(82);
      writer.fork();
      PersistentVolumeClaimVolumeSource.encode(persistentVolumeClaim, writer);
      writer.ldelim();
    }

    const rbd = message.rbd;
    if (rbd !== null) {
      writer.uint32(90);
      writer.fork();
      RBDVolumeSource.encode(rbd, writer);
      writer.ldelim();
    }

    const flexVolume = message.flexVolume;
    if (flexVolume !== null) {
      writer.uint32(98);
      writer.fork();
      FlexVolumeSource.encode(flexVolume, writer);
      writer.ldelim();
    }

    const cinder = message.cinder;
    if (cinder !== null) {
      writer.uint32(106);
      writer.fork();
      CinderVolumeSource.encode(cinder, writer);
      writer.ldelim();
    }

    const cephfs = message.cephfs;
    if (cephfs !== null) {
      writer.uint32(114);
      writer.fork();
      CephFSVolumeSource.encode(cephfs, writer);
      writer.ldelim();
    }

    const flocker = message.flocker;
    if (flocker !== null) {
      writer.uint32(122);
      writer.fork();
      FlockerVolumeSource.encode(flocker, writer);
      writer.ldelim();
    }

    const downwardAPI = message.downwardAPI;
    if (downwardAPI !== null) {
      writer.uint32(130);
      writer.fork();
      DownwardAPIVolumeSource.encode(downwardAPI, writer);
      writer.ldelim();
    }

    const fc = message.fc;
    if (fc !== null) {
      writer.uint32(138);
      writer.fork();
      FCVolumeSource.encode(fc, writer);
      writer.ldelim();
    }

    const azureFile = message.azureFile;
    if (azureFile !== null) {
      writer.uint32(146);
      writer.fork();
      AzureFileVolumeSource.encode(azureFile, writer);
      writer.ldelim();
    }

    const configMap = message.configMap;
    if (configMap !== null) {
      writer.uint32(154);
      writer.fork();
      ConfigMapVolumeSource.encode(configMap, writer);
      writer.ldelim();
    }

    const vsphereVolume = message.vsphereVolume;
    if (vsphereVolume !== null) {
      writer.uint32(162);
      writer.fork();
      VsphereVirtualDiskVolumeSource.encode(vsphereVolume, writer);
      writer.ldelim();
    }

    const quobyte = message.quobyte;
    if (quobyte !== null) {
      writer.uint32(170);
      writer.fork();
      QuobyteVolumeSource.encode(quobyte, writer);
      writer.ldelim();
    }

    const azureDisk = message.azureDisk;
    if (azureDisk !== null) {
      writer.uint32(178);
      writer.fork();
      AzureDiskVolumeSource.encode(azureDisk, writer);
      writer.ldelim();
    }

    const photonPersistentDisk = message.photonPersistentDisk;
    if (photonPersistentDisk !== null) {
      writer.uint32(186);
      writer.fork();
      PhotonPersistentDiskVolumeSource.encode(photonPersistentDisk, writer);
      writer.ldelim();
    }

    const projected = message.projected;
    if (projected !== null) {
      writer.uint32(210);
      writer.fork();
      ProjectedVolumeSource.encode(projected, writer);
      writer.ldelim();
    }

    const portworxVolume = message.portworxVolume;
    if (portworxVolume !== null) {
      writer.uint32(194);
      writer.fork();
      PortworxVolumeSource.encode(portworxVolume, writer);
      writer.ldelim();
    }

    const scaleIO = message.scaleIO;
    if (scaleIO !== null) {
      writer.uint32(202);
      writer.fork();
      ScaleIOVolumeSource.encode(scaleIO, writer);
      writer.ldelim();
    }

    const storageos = message.storageos;
    if (storageos !== null) {
      writer.uint32(218);
      writer.fork();
      StorageOSVolumeSource.encode(storageos, writer);
      writer.ldelim();
    }

    const csi = message.csi;
    if (csi !== null) {
      writer.uint32(226);
      writer.fork();
      CSIVolumeSource.encode(csi, writer);
      writer.ldelim();
    }

    const ephemeral = message.ephemeral;
    if (ephemeral !== null) {
      writer.uint32(234);
      writer.fork();
      EphemeralVolumeSource.encode(ephemeral, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): VolumeSource {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new VolumeSource();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hostPath = HostPathVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 2:
          message.emptyDir = EmptyDirVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 3:
          message.gcePersistentDisk = GCEPersistentDiskVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 4:
          message.awsElasticBlockStore =
            AWSElasticBlockStoreVolumeSource.decode(reader, reader.uint32());
          break;

        case 5:
          message.gitRepo = GitRepoVolumeSource.decode(reader, reader.uint32());
          break;

        case 6:
          message.secret = SecretVolumeSource.decode(reader, reader.uint32());
          break;

        case 7:
          message.nfs = NFSVolumeSource.decode(reader, reader.uint32());
          break;

        case 8:
          message.iscsi = ISCSIVolumeSource.decode(reader, reader.uint32());
          break;

        case 9:
          message.glusterfs = GlusterfsVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 10:
          message.persistentVolumeClaim =
            PersistentVolumeClaimVolumeSource.decode(reader, reader.uint32());
          break;

        case 11:
          message.rbd = RBDVolumeSource.decode(reader, reader.uint32());
          break;

        case 12:
          message.flexVolume = FlexVolumeSource.decode(reader, reader.uint32());
          break;

        case 13:
          message.cinder = CinderVolumeSource.decode(reader, reader.uint32());
          break;

        case 14:
          message.cephfs = CephFSVolumeSource.decode(reader, reader.uint32());
          break;

        case 15:
          message.flocker = FlockerVolumeSource.decode(reader, reader.uint32());
          break;

        case 16:
          message.downwardAPI = DownwardAPIVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 17:
          message.fc = FCVolumeSource.decode(reader, reader.uint32());
          break;

        case 18:
          message.azureFile = AzureFileVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 19:
          message.configMap = ConfigMapVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 20:
          message.vsphereVolume = VsphereVirtualDiskVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 21:
          message.quobyte = QuobyteVolumeSource.decode(reader, reader.uint32());
          break;

        case 22:
          message.azureDisk = AzureDiskVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 23:
          message.photonPersistentDisk =
            PhotonPersistentDiskVolumeSource.decode(reader, reader.uint32());
          break;

        case 26:
          message.projected = ProjectedVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 24:
          message.portworxVolume = PortworxVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 25:
          message.scaleIO = ScaleIOVolumeSource.decode(reader, reader.uint32());
          break;

        case 27:
          message.storageos = StorageOSVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        case 28:
          message.csi = CSIVolumeSource.decode(reader, reader.uint32());
          break;

        case 29:
          message.ephemeral = EphemeralVolumeSource.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  hostPath: HostPathVolumeSource | null;
  emptyDir: EmptyDirVolumeSource | null;
  gcePersistentDisk: GCEPersistentDiskVolumeSource | null;
  awsElasticBlockStore: AWSElasticBlockStoreVolumeSource | null;
  gitRepo: GitRepoVolumeSource | null;
  secret: SecretVolumeSource | null;
  nfs: NFSVolumeSource | null;
  iscsi: ISCSIVolumeSource | null;
  glusterfs: GlusterfsVolumeSource | null;
  persistentVolumeClaim: PersistentVolumeClaimVolumeSource | null;
  rbd: RBDVolumeSource | null;
  flexVolume: FlexVolumeSource | null;
  cinder: CinderVolumeSource | null;
  cephfs: CephFSVolumeSource | null;
  flocker: FlockerVolumeSource | null;
  downwardAPI: DownwardAPIVolumeSource | null;
  fc: FCVolumeSource | null;
  azureFile: AzureFileVolumeSource | null;
  configMap: ConfigMapVolumeSource | null;
  vsphereVolume: VsphereVirtualDiskVolumeSource | null;
  quobyte: QuobyteVolumeSource | null;
  azureDisk: AzureDiskVolumeSource | null;
  photonPersistentDisk: PhotonPersistentDiskVolumeSource | null;
  projected: ProjectedVolumeSource | null;
  portworxVolume: PortworxVolumeSource | null;
  scaleIO: ScaleIOVolumeSource | null;
  storageos: StorageOSVolumeSource | null;
  csi: CSIVolumeSource | null;
  ephemeral: EphemeralVolumeSource | null;

  constructor(
    hostPath: HostPathVolumeSource | null = null,
    emptyDir: EmptyDirVolumeSource | null = null,
    gcePersistentDisk: GCEPersistentDiskVolumeSource | null = null,
    awsElasticBlockStore: AWSElasticBlockStoreVolumeSource | null = null,
    gitRepo: GitRepoVolumeSource | null = null,
    secret: SecretVolumeSource | null = null,
    nfs: NFSVolumeSource | null = null,
    iscsi: ISCSIVolumeSource | null = null,
    glusterfs: GlusterfsVolumeSource | null = null,
    persistentVolumeClaim: PersistentVolumeClaimVolumeSource | null = null,
    rbd: RBDVolumeSource | null = null,
    flexVolume: FlexVolumeSource | null = null,
    cinder: CinderVolumeSource | null = null,
    cephfs: CephFSVolumeSource | null = null,
    flocker: FlockerVolumeSource | null = null,
    downwardAPI: DownwardAPIVolumeSource | null = null,
    fc: FCVolumeSource | null = null,
    azureFile: AzureFileVolumeSource | null = null,
    configMap: ConfigMapVolumeSource | null = null,
    vsphereVolume: VsphereVirtualDiskVolumeSource | null = null,
    quobyte: QuobyteVolumeSource | null = null,
    azureDisk: AzureDiskVolumeSource | null = null,
    photonPersistentDisk: PhotonPersistentDiskVolumeSource | null = null,
    projected: ProjectedVolumeSource | null = null,
    portworxVolume: PortworxVolumeSource | null = null,
    scaleIO: ScaleIOVolumeSource | null = null,
    storageos: StorageOSVolumeSource | null = null,
    csi: CSIVolumeSource | null = null,
    ephemeral: EphemeralVolumeSource | null = null
  ) {
    this.hostPath = hostPath;
    this.emptyDir = emptyDir;
    this.gcePersistentDisk = gcePersistentDisk;
    this.awsElasticBlockStore = awsElasticBlockStore;
    this.gitRepo = gitRepo;
    this.secret = secret;
    this.nfs = nfs;
    this.iscsi = iscsi;
    this.glusterfs = glusterfs;
    this.persistentVolumeClaim = persistentVolumeClaim;
    this.rbd = rbd;
    this.flexVolume = flexVolume;
    this.cinder = cinder;
    this.cephfs = cephfs;
    this.flocker = flocker;
    this.downwardAPI = downwardAPI;
    this.fc = fc;
    this.azureFile = azureFile;
    this.configMap = configMap;
    this.vsphereVolume = vsphereVolume;
    this.quobyte = quobyte;
    this.azureDisk = azureDisk;
    this.photonPersistentDisk = photonPersistentDisk;
    this.projected = projected;
    this.portworxVolume = portworxVolume;
    this.scaleIO = scaleIO;
    this.storageos = storageos;
    this.csi = csi;
    this.ephemeral = ephemeral;
  }
}
