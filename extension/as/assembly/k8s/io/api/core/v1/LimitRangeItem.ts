// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v1.3.0
//   protoc        v3.20.1

import { Writer, Reader } from "as-proto/assembly";
import { Quantity } from "../../../apimachinery/pkg/api/resource/Quantity";

export class LimitRangeItem {
  static encode(message: LimitRangeItem, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.type);

    const max = message.max;
    if (max !== null) {
      const maxKeys = max.keys();
      for (let i: i32 = 0; i < maxKeys.length; ++i) {
        const maxKey = maxKeys[i];
        writer.uint32(18);
        writer.fork();
        writer.uint32(10);
        writer.string(maxKey);
        writer.uint32(18);
        writer.fork();
        Quantity.encode(max.get(maxKey), writer);
        writer.ldelim();
        writer.ldelim();
      }
    }

    const min = message.min;
    if (min !== null) {
      const minKeys = min.keys();
      for (let i: i32 = 0; i < minKeys.length; ++i) {
        const minKey = minKeys[i];
        writer.uint32(26);
        writer.fork();
        writer.uint32(10);
        writer.string(minKey);
        writer.uint32(18);
        writer.fork();
        Quantity.encode(min.get(minKey), writer);
        writer.ldelim();
        writer.ldelim();
      }
    }

    const default_ = message.default;
    if (default_ !== null) {
      const defaultKeys = default_.keys();
      for (let i: i32 = 0; i < defaultKeys.length; ++i) {
        const defaultKey = defaultKeys[i];
        writer.uint32(34);
        writer.fork();
        writer.uint32(10);
        writer.string(defaultKey);
        writer.uint32(18);
        writer.fork();
        Quantity.encode(default_.get(defaultKey), writer);
        writer.ldelim();
        writer.ldelim();
      }
    }

    const defaultRequest = message.defaultRequest;
    if (defaultRequest !== null) {
      const defaultRequestKeys = defaultRequest.keys();
      for (let i: i32 = 0; i < defaultRequestKeys.length; ++i) {
        const defaultRequestKey = defaultRequestKeys[i];
        writer.uint32(42);
        writer.fork();
        writer.uint32(10);
        writer.string(defaultRequestKey);
        writer.uint32(18);
        writer.fork();
        Quantity.encode(defaultRequest.get(defaultRequestKey), writer);
        writer.ldelim();
        writer.ldelim();
      }
    }

    const maxLimitRequestRatio = message.maxLimitRequestRatio;
    if (maxLimitRequestRatio !== null) {
      const maxLimitRequestRatioKeys = maxLimitRequestRatio.keys();
      for (let i: i32 = 0; i < maxLimitRequestRatioKeys.length; ++i) {
        const maxLimitRequestRatioKey = maxLimitRequestRatioKeys[i];
        writer.uint32(50);
        writer.fork();
        writer.uint32(10);
        writer.string(maxLimitRequestRatioKey);
        writer.uint32(18);
        writer.fork();
        Quantity.encode(
          maxLimitRequestRatio.get(maxLimitRequestRatioKey),
          writer
        );
        writer.ldelim();
        writer.ldelim();
      }
    }
  }

  static decode(reader: Reader, length: i32): LimitRangeItem {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new LimitRangeItem();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.string();
          break;

        case 2:
          let maxKey: string = "";
          let maxValue: Quantity | null = null;
          let maxHasKey: bool = false;
          let maxHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                maxKey = reader.string();
                maxHasKey = true;
                break;

              case 2:
                maxValue = Quantity.decode(reader, reader.uint32());
                maxHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.max === null) {
              message.max = new Map<string, Quantity>();
            }
            const max = message.max;
            if (max !== null && maxHasKey && maxHasValue && maxValue !== null) {
              max.set(maxKey, maxValue);
            }
          }
          break;

        case 3:
          let minKey: string = "";
          let minValue: Quantity | null = null;
          let minHasKey: bool = false;
          let minHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                minKey = reader.string();
                minHasKey = true;
                break;

              case 2:
                minValue = Quantity.decode(reader, reader.uint32());
                minHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.min === null) {
              message.min = new Map<string, Quantity>();
            }
            const min = message.min;
            if (min !== null && minHasKey && minHasValue && minValue !== null) {
              min.set(minKey, minValue);
            }
          }
          break;

        case 4:
          let defaultKey: string = "";
          let defaultValue: Quantity | null = null;
          let defaultHasKey: bool = false;
          let defaultHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                defaultKey = reader.string();
                defaultHasKey = true;
                break;

              case 2:
                defaultValue = Quantity.decode(reader, reader.uint32());
                defaultHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.default === null) {
              message.default = new Map<string, Quantity>();
            }
            const default_ = message.default;
            if (
              default_ !== null &&
              defaultHasKey &&
              defaultHasValue &&
              defaultValue !== null
            ) {
              default_.set(defaultKey, defaultValue);
            }
          }
          break;

        case 5:
          let defaultRequestKey: string = "";
          let defaultRequestValue: Quantity | null = null;
          let defaultRequestHasKey: bool = false;
          let defaultRequestHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                defaultRequestKey = reader.string();
                defaultRequestHasKey = true;
                break;

              case 2:
                defaultRequestValue = Quantity.decode(reader, reader.uint32());
                defaultRequestHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.defaultRequest === null) {
              message.defaultRequest = new Map<string, Quantity>();
            }
            const defaultRequest = message.defaultRequest;
            if (
              defaultRequest !== null &&
              defaultRequestHasKey &&
              defaultRequestHasValue &&
              defaultRequestValue !== null
            ) {
              defaultRequest.set(defaultRequestKey, defaultRequestValue);
            }
          }
          break;

        case 6:
          let maxLimitRequestRatioKey: string = "";
          let maxLimitRequestRatioValue: Quantity | null = null;
          let maxLimitRequestRatioHasKey: bool = false;
          let maxLimitRequestRatioHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                maxLimitRequestRatioKey = reader.string();
                maxLimitRequestRatioHasKey = true;
                break;

              case 2:
                maxLimitRequestRatioValue = Quantity.decode(
                  reader,
                  reader.uint32()
                );
                maxLimitRequestRatioHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.maxLimitRequestRatio === null) {
              message.maxLimitRequestRatio = new Map<string, Quantity>();
            }
            const maxLimitRequestRatio = message.maxLimitRequestRatio;
            if (
              maxLimitRequestRatio !== null &&
              maxLimitRequestRatioHasKey &&
              maxLimitRequestRatioHasValue &&
              maxLimitRequestRatioValue !== null
            ) {
              maxLimitRequestRatio.set(
                maxLimitRequestRatioKey,
                maxLimitRequestRatioValue
              );
            }
          }
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  type: string;
  max: Map<string, Quantity>;
  min: Map<string, Quantity>;
  default: Map<string, Quantity>;
  defaultRequest: Map<string, Quantity>;
  maxLimitRequestRatio: Map<string, Quantity>;

  constructor(
    type: string = "",
    max: Map<string, Quantity> = new Map(),
    min: Map<string, Quantity> = new Map(),
    default_: Map<string, Quantity> = new Map(),
    defaultRequest: Map<string, Quantity> = new Map(),
    maxLimitRequestRatio: Map<string, Quantity> = new Map()
  ) {
    this.type = type;
    this.max = max;
    this.min = min;
    this.default = default_;
    this.defaultRequest = defaultRequest;
    this.maxLimitRequestRatio = maxLimitRequestRatio;
  }
}
